
#  Cи за 42 минуты (ну почти) / [[VIDEO]](https://youtu.be/tUfXuSI7rUU) #

Привет всем и добро пожаловать на этот урок: `Cи за 42 минуты / (ну почти)`.

# 1. Предисловие  #

### 1.1 - Это не урок по Си  ###

Прежде всего, небольшое уточнение: этот урок не предназначен для того, чтобы научить вас программировать на Cи. Это не полное описание языка. Его единственная цель - показать элементы, которые вам понадобятся, чтобы закончить этот бассейн.

### 1.2 - Введение в Си "бассейна"  ###

Это подраздел Си позволит вам выполнить все то, что от вас требуется во время этого бассейна.


# 2. Что такое компьютер?  #

Перед тем, как начать писать код, первое, что вам нужно понять:
* Что такое компьютер?
* Что внутри него?
* И как это работает?

Итак, машина состоит из 3 элементов:
1. Первый элемент - это процессор "ЦП" ("CPU"). Это то, что обрабатывает все вычисления, сравнения. Все эти действия выполняются процессором.
2. Второй элемент - это оперативная память "ОЗУ" ("RAM"). "ОЗУ" - это инструмент, объект, который хранит все то, что запомнил компьютер. [alt: хранит все то, что происходит на компьютере (данные обрабатываемые процессором и машинный код (программы))]. Так что этот второй элемент очень важен.
3. И, наконец, третий элемент сделан из компьютерной периферии / устройств ("devices"), которые обеспечивают вам соединение (связь) между вашим компьютером и остальным миром.

И так, мы имеем эти 3 элемента.

Эти 3 элемента связаны между собой системой, называемой "BUS" (компьютерной шиной), которая позволяет информации передаваться. Также есть "clock" система [alt: сиcтема синхронизации (генератор тактовых импульсов)], которая позволяет элементам, всему этому, работать вместе. Конечно, компьютер гораздо сложнее, чем в моем описании, но именно такое, я бы сказал видение, или хотя бы представление нам понадобится во время бассейна, а также, на некоторое время, в течении 1-го года в школе. Итак, давайте пока оставим это базовое описание.

Я повторюсь: процессор "ЦП", то есть блок обработки данных; система памяти, которую мы называем "ОЗУ" и периферийные  устройства, система взаимодействия с остальным миром.

# 3. А само программирование, что это такое? #

### 3.1 - Инструкции для процессора  ###

Программирование, по итогу, (в сравнении с тем, что мы до это этого видели, имея в виду парадигму описания компьютера), состоит в том, чтобы давать какие-либо инструкции процессору, то есть список элементарных действий, которые будут обрабатывать данные.

### 3.2 - Данные на обработку ###

Так что мы сможем выполнять чрезвычайно простые действия. Например, сравнение двух данных, простая операция, такая как сложение, вычитание или деление. Мы сможем перенаправлять информацию в новый адрес, таким образом, скопировав данные адреса в другой. Мы сможем выполнять базовую арифметику, базовые сравнения и мы сможем отправлять эти данные на устройства, например, отображать их на экране или просто отправить их куда-либо.

### 3.3 - И то, и то находится в ОЗУ  ###

Что вы должны понимать, так это то, что мы стараемся сделать вещи, которые являются очень элементарными, НО выполнены они будут очень быстро и в очень большом количестве. Эти элементарные инструкции позволят нам симулировать чрезвычайно сложное поведение, возможно даже симулировать интеллект.

В любом случае, на сегодняшний день, наша система программирования имеет возможность выполнять не только элементарные вещи.


# 4. Так, что там насчет Си?  #

### 4.1 - Простые языки программирования  ###

В конце концов, компьютер будет обрабатывать язык, который называется компьютерным языком, который является очень элементарным языком, непосредственно составленным из машинного кода («машинный язык»), который довольно сложен для человеческих существ.

Язык Си - это некий внешний слой всего этого. Это относительно простой язык, близкий к языку компьютера, тут этот язык будет являться последовательным языком, который в целом имеет перевод довольно элементарных операций.

Так что, ничего сложного тут нет. В любом случае, язык будет читаемым и довольно простым для того, чтобы человек мог его использовать, что само по себе делает сам процесс работы с ним более эффективным.

### 4.2 - Компилируемые языки  ###

Итак, у нас есть сложная система, значит мы преобразуем язык Си, (код который мы записали куда-то), в компьютерный язык. Потом, этот компьютерный язык будет обработан процессором, и он будет являться читаемым для людей, и он будет компилироваться (так что он еще более эффективен), давая набор функциональных возможностей, которые относительно эволюционировали, что позволят нам нормально работать.

### 4.3 - Среда операционных систем   ###

Операционная система - это еще один важный слой для интеграции. Операционная система - это программное обеспечение, которое заставляет компьютер работать. Она запускается при запуске самой машины и позволяет иметь интерфейс между самой машиной и пользователем. ОС - Операционная система. Позже, мы увидим более полные определения и описания, потому что сам по себе очень сложный объект, который разрабатывался в течении очень долгого времени и над которым было проделано много работ. ОС - это результат сильной эволюции.

И этот объейкт, ОС, будет управлять всем функционированием компьютера, а ваша программа будет "взаимодействовать" с этой ОС. Чтобы было понятнее, когда например вы захотите отобразить символ, то ваша программа, написанная на Си, скажет ОС через "системные вызовы": "Я хочу, чтобы этот символ был отображен" и именно ОС выполнит эту работу. А это значит, что в вашей программе не нужно писать код всей системы, которая должна придти к отображению символа.

Итак, Си дает вам возможность написать простые инструкции, которые позволят вам "взаимодействовать" с ОС (операционной системой), которая в свою очередь будет также "взаимодействовать" с аппаратной частью, для отображения или выполнения необходимых вам действий.

# 5. Инструкции и информация  #

### 5.1 - Программа на Си имеет и то, и то  ###

Как мы видели ранее, компьютер имеет память, следовательно он хранит данные, тоесть следуя инструкциям он сможет выполнять процессы над этими данными.

### 5.2 - ОЗУ (RAM) - это последовательность байтов (8 бит) ###

Программа на языке Си - это своего рода представление, не только данных, которые мы будем обрабатывать (что означает, что мы получим информацию об этих данных), но также и инструкций. В ОЗУ данные отображаются группами по 8, которые называются байтами. Эта группа состоит из 8 битов, и так 8: 1 и 0, и все это мы зовем байтом (8 bit = 10110101 => 1 byte).

Размер | Название | Пример
-------|----------|-------
1      | Bit      | 0
8      | Byte	    | 10110101

### 5.3 - Каждый байт имеет уникальный адрес в ОЗУ ###

Он (1 байт) позволяет нам хранить числа от 0 до 255, в зависимости от их представления.

> В русском языке октет обычно называют byte (октет = 1byte = 8bit) может принимать 256 возможных состояний (кодов, значений, комбинаций битов (нулей и единиц). ru.wikipedia.org/wiki/Байт

### 5.4 - Си должна получать доступ к байтам, чтобы хранить информацию ###

И каждому из этих байтов, будет дан (присвоен) адрес, который позволит нам его распознать и найти. Язык Си позволит нам работать с этими байтами и, таким образом, работать с адресной системой.

# 6. Система типов Си  #
Си использует типы для представления данных, поэтому у нас будет несколько типов.

Тип                | Число байтов | Диапазон
-------------------|--------------|---------
char               | 1 – 8 bit    | -128 / +127
unsigned char      | 1 – 8 bit	  | 0 / 255
short	             | 2 – 16 bit	  | -32768 / +32767
unsigned short     | 2 – 16 bit   |	0 / 65536
int	               | 4 – 32 bit   | −2147483648 / 2147483647
unsigned int       | 4 – 32 bit	  | 0 / 4 294 967 295
long long          | 8 – 64 bit   |	−9223372036854775808 / +922…
unsigned long long | 8 – 64 bit	  | 0 / 18446744073709551615
\*	               | 8 – 64 bit   |	адрес

1. Первый тип - обычно мы называем его `CHAR`, который является 8-битным, то есть 1 байтом. Таким образом, он может хранить значения в диапазоне от -128 до +127, и на него может воздействовать базовая арифметика, которая позволит ему обрабатывать все обычные процессы: деления, вычитания и т.д.
2. Второй тип - это `UNSIGNED CHAR`, который также является 8-битным, но хранить значения он может в диапазоне от 0 до 255.
3. Далее, у вас есть то, что мы обычно называем `SHORT`, который является 2-байтным, то есть из 16-бит, который дает возможность нам хранить значения в диапазоне от -32768 до +32767.
4. У вас также есть `UNSIGNED SHORT`, опустим подробности...
5. Есть `INT`, который составляет 4-байта и как правило это структура данных, которую мы используем чаще всего, потому что она позволяет нам выполнять большинство процессов.
6. Также у вас есть `UNSIGNED INT`, `LONG` и `LONG LONG`, которые позволяют нам хранить данные до 64-бит. У нас конечно также есть `UNSIGNED LONG LONG`.
7. И у вас есть последний тип - `*`, который называется "звезда / астериск / указатель", который позволяет хранить не только данные, но и адрес данных. Можно считать, что адрес данных - это тоже данные, но существует специальная арифметика, которую мы увидим чуть позже.


# 7. Структура программы #

### 7.1 - Программа - это набор функций ###

Теперь, когда мы знаем, как представлять данные, давайте поговорим о структуре программ. Структура программ - это набор функций.

### 7.2 Фнукция - это закрытый объект, который имеет: ###

* Входные данные: параметры 
* Фрагмент выходных данных: возвращаемое значение 

То, что мы называем функцией, это объект, (который считается закрытым, поскольку предполагается, что данные в этом объекте должны быть закрыты для остального мира), который получает информацию (параметры) и который возвращает результат, и между этими всем существует процесс, и мы увидим как это все работает.

### 7.3 Функция состоит из двух вещей: ###

* Инструкции для ЦП 
* Локальных данных: переменных 


# 8. Первые синтаксические элементы #

### 8.1 - Объявление функции ###

Здесь вы видите первый синтаксический элемент: объявление функции.

```c
type  name(type1 param1, type2 param2, ...)
BLOCK
```

Функция может быть объявлена довольно просто. Мы определяем ее тип `type`, т.е. тип того, что возвращает функция, потому что функция принимает такие значения, как входные, которые мы называем параметры, и возвращаем результат. Таким образом, тип, который вы видите первым в этом прототипе, является типом возвращаемого значения.

Затем у нас идет имя функции `name( )`, а потом список параметров (внутри скобок), которые каждый раз являются, типом 1-го параметра, названием 1-го параметра, типом 2-го параметра, названием 2-го параметра, и т.д., и т.д... Может быть столько параметров, сколько мы захотим, также их вообще может и не быть. Если параметры отсутствуют, мы просто пишем открывающие скобки `(`, закрывающие скобки `)`. Все это является тем, что возвращает функция, какие параметры она принимает, и после этого идет то, что у нас называется `Block` (блок).

### 8.2 - Блок кода: ###

```c
{
  local variables declaratin // объявление локальных переменных

  instructions // инструкции
}
```

Блок содержит саму функцию. Функция всегда разделена на две части и вторая часть (блок) находится между фигурными скобками `{}`. Итак, у нас есть открывающаяся фигурная скобка `{`, потом объявление локальных переменных, после которой следуют инструкции. У нас может быть только одна инструкция, может и не быть локальных переменных, может и не быть инструкций, и мы всегда заканчиваем закрывающей фигурной скобкой `}`.

# 9. Первый пример #

### Объявление функции "sum" ###

Вот краткий пример небольшой функции.

```c
int sum(int value1, int value2)
{
  int total;

  instructions
}
```

Здесь мы объявляем функцию `sum()`, которая возвращает `int`, и которая принимает 2 параметра: параметр `value1`, который имеет тип `int`, и 2-й параметр `value2`, который также имеет тип `int`. Потом пишется блок функции, то есть открывая фигурную скобку `{`.

`int total` - объявляем новый `int` с именем `total`, который является локальной переменной функции. Функция является закрытой, что означает, что снаружи этой функции, эта переменная не существует, поэтому она локальна (local).

Затем у нас идут инструкции, в этом примере их нет, но по сути они всегда находятся там. И, наконец, закрывающаяся фигурная скобка `}`: конец блока, конец функции.

# 10. Составные (сложные) типы #

В Си мы можем объявлять, то что мы обычно называем комбинированные типы. Это структуры данных, которые сделаны из элементарных типов, которые мы видели ранее. Их несколько, но во время этого бассейна, мы будем использовать только пару типов. Первым является массив (array).

### 10.1 - Массивы ###

```c
type  name[numeric_value];     int tab[42];
```

Массив - это последовательность объектов одного типа (в памяти). Они легко объявляются: тип, имя, открывающаяся квадратная скобка `{`, количество элементов в массиве, закрывающаяся квадратная скобка `}`.

Справа у вас есть пример: `int tab[42]` - это объявление массива, который может содержать 42 элемента типа int. Индекс массива начинается с 0 до 41. Мы всегда начинаем с 0. Итак, с этим массивом вы зарезервировали в памяти 42 элемента типа int. Чтобы получить к ним доступ, мы пишем имя, открываем квадратную скобку `[`, номер нужного нам элемента типа int, и закрываем квадратной скобкой `]`. Например, если мы напишем `int tab[12]`, то получим 13-ый int элемент массива.

### 10.2 - Структуры  ###

```c
struct  struct_name           struct s_fortytwo
{                             {
  type  name;                   int   a;
  type  name;                   char  b[21];
};                            };
```

Второй комбинированный тип чуть сложнее (мы будем использовать его позже) и он называется структура данных. Структура позволит нам определить представление объекта в памяти, который будет состоять из базовых элементов, которые также могут быть структурами. Вы должны знать, что мы можем связывать структуры, массивы и т.д.

Давайте посмотрим, как объявить структуру: мы пишем `struct <имя_структуры>`, открываем фигурную скобку `{`, далее объявляем компоненты этой структуры (тип, имя и т.д.), закрываем фигурную скобку `}` и точку с запятой `;`. Тут, мы только что объявили структуру.

Справа есть пример, где мы объявляем структуру `s_fortytwo`. Он состоит из `int` с именем `a` и массива из 21 символа с именем `b`. Мы объявляем это простым способом, указанным ниже.

### 10.3 - Объявление ###

```c
struct  struct_name name;       struct  s_fortytwo a;
```

Мы объявляем структуру, и когда мы пишем `struct`, имя структуры, имя переменной, точка с запятой, то резервируется необходимую область памяти, и когда мы используем это имя, программа будет знать, что мы говорим о структуре.


# 11. Нормы #

Компилятор в Си довольно гибок, с точки зрения синтаксиса. Вы можете писать какие-либо вещи разными способами. Но чтобы сделать вещи более читабельными и иметь некоторую последовательность, мы установили стандарт (Norm). Этот стандарт мы представим вам позже. У вас будет отдельный урок на эту тему. Вам важно понять, что использование этого стандарта имеет множество преимуществ:

1. Первое преимущество заключается в том, что вам будет легче читать код и наоборот.
2. Второе преимущество в том, что это поможет вам научиться структурированно программировать. Вы увидите, что даже если вы до этого уже занимались программированием, то школьный стандарт все равно будет являться, своего рода, адаптацией.
3. Третье, большое преимущество в том, что она придает "внешний вид" и улучшает ваш скилл чтения чужого кода. Когда мы будем читать чужой код, то использование стандарта, при написании, позволит нам читать этот его быстрее.

Мы просим вас соблюдать стандарт, у нас также есть программа, которая проверяет соблюдение этого стандарта.


# 12. Отправная точка  #

### 12.1 - Откуда начать? ###

Мы видели, что программа представляет собой набор функций, и что их может быть много. Так откуда начать?

### 12.2 - Обязательная функция с определенным названием : `main` ###

Было взято за основу, что в синтаксисе языка Си изначально, функцией, которая будет выполняться первой, будет функция `main()`, которая инициирует выполнение программы.

### 12.3 - Где-то в вашем коде должно быть: ###

```c
int main()
{

}
```

Так что, если вы создадите программу, то где-то в вашем коде, будет функция `main()`. Это функция, которая принимает определенное количество параметров, позже вы увидите, как они работают и как их использовать. `main()` возвращает `int`, вы также увидите, как все это работает. Таким образом, у нас будет систематическое объявление `int main()`, потом параметры между круглыми скобками, если они есть и блок функции `{}`.

# 13. 3 вида инструкций  #

Теперь, когда мы увидели общую структуру программы и увидели, как представлять данные, все что нам остается так это понять, как работают инструкции.

### 13.1 - Блоки кода: ###

```c
{
  declarations; // объявления

  instructions; // инструкции
}
```

Конечно, зная уже, как объявлять данные, нам нужно научиться работать с этими данными. Это довольно просто. Есть 3 вида инструкций. Есть то, что мы называем "blocks" (блоки), которые, как мы видели, всегда состоят из открывающейся фигурной скобки `{`, объявлении локальных переменных для этого блока (локальных по отношению к блоку), и инструкций, которые будут выполняться этим блоком, и закрывающаяся фигурная скобка `}`.

### 13.2 - Выражения: ###

```c
expression; // выражение

// Выражение - это вычисление, которое всегда вычисляется в виде числового значения.
// An expression is a computation that always evaluates to a numerical value.
```

Есть также то, что мы называем "выражениями", за которым следует точка с запятой `;`, и выполняется численное вычисление или анализ. Позже мы к этому еще придем.

### 13.3 - Управляющие структуры  ###

А затем, у нас есть то, что мы называем "управляющие структуры", которые позволяют нам контролировать выполнение серий инструкций внутри блока.

# 14. Выражения  #

Начнем с выражений. Итак, выражения, как мы уже говорили, представляют собой набор вычислений, которые дают результаты.

### 14.1 - Непосредственные числовые значения  ###

```txt
0     42    0x1A    010
```

Числовое значение является самым простым таким вычислением. Например, если вы напишите, тут 0 и 42, вы также можете написать номер в шестнадцатеричной системе (hex) - 0X1A, в восьмеричной (octal) - 010, и оно будет вычислено в своем собственном значении, это означает, что компилятор удостоверится, что оно соответствует результату.

### 14.2 - Переменные  ###

```c
a           // Пример: `int a;`
b[18]       // Пример: `char b[63];`
sft_var.a   // Пример со структурой
```

Второй тип выражений: переменные, как только мы переходим к переменным, когда мы их используем, то происходит вычисление непосредственно значения переменных. Если, например, у вас есть значение в `int a`, как в примере, то написание `a` будет стоить значению, которое находится в самом `a`.

То же самое для массива: если вы написали `b[18]`, то он будет искать 19-й элемент, находящийся в `b`.

В случае структуры, если у вас есть элемент структуры с названием `sft_var.a`, он будет искать элемент `a` в структуре `sft_var`. Таким образом, переменная вычисляется непосредственно по содержащемуся в ней значению.


### 14.3 - Вызовы функций: ###

```c
sum(18, a)
```

Вызов функции - так мы обычно называем третий тип выражений. Мы пишем имя функции, параметры, которые мы передадим этой функции, компилятор вызовет эту функцию и произойдет вычисление возвращаемого значения этой функции. Мы видели, что функция принимает параметры ввода, выполняет процесс, который мы ее просим, и возвращает значение, и это значение будет задано вместо самой функции.

### 14.4 - Вычисления:  `+ - * / % ()` ###

```c
1 + 3 – ( a * 42 + b[0]) / sum(21, 34 – b[10])
```

Внутри этого вычисления находится функция. Мы можем комбинировать все эти элементы благодаря вычислениям. Таким образом, компилятор будет обрабатывать всю арифметику, и, как вы видите ниже, мы можем писать довольна сложные вещи.

Если вы напишите `1 + 3`, то будет взята `1` и к ней добавят `3`. `-` и компилятор обрабатывает скобки и приоритетные операции. Есть `b[0]`, который получит первый элемент массива `b`. Когда мы пишем `a * 42`, то компилятор получит значение `a`. Потом он разделит на сумму 2 элементов, возвращаемую функцией `sum()`.

Компилятор произведет анализ, вычислит результат этих арифметических выражений и сделает он это в правильном порядке.

### 14.5 - Присвоения: ###

```c
a = 42
b[2 + a] = sum(12, 30)
sft_var.a = 0
```

Последний тип выражений: присвоения. Присвоение, например, - это когда мы пишем `a = 42`. Компилятор присвоит значение `42` в переменную `a` и вернет, в результате, `42`. Мы систематически будем иметь присвоение и вычисление.

К примеру, если вы напишите `b[2 + a]`, то мы возьмем значение содержащееся в `a` и добавим к нему `2` и это значение будет служить индексом, чтобы по нему перейти к чтению в массиве `b`. Мы вычислим результат функции справа. Присвоим его элементу массива и вернем результат функции. Это является присвоением и оно изменило данные в самой переменной.

# 15. Выражения (опять) #

### 15.1 - Операторы сравнения (компараторы): `== != < > <= >= || && !` ###

```c
a < 2 + b[23]
a - 2 == 32 || b[11] + 3 >= 17
```

Есть и другие выражения. У нас есть то, что мы называем Операторы сравнения. Оператор сравнения в Си - это оператор, который, как и любое другое выражение, будет оценивать по значению. Мы называем `true` возвращаемое значение `1` и `false` возвращаемое значение `0`. Поэтому, например, когда вы пишите `a == b`, то будет произведена проверка равенства содержимого переменной `a` с содержимым переменной `b`. Если содержимое этих двух равно, то вернется `1`, если иначе (else) то вернется `0`.

Все операторы сравнения работают одинаково. Другой пример, если вы напишите `a < b`, то будет произведена проверка значения `a` по отношению к `b`, если `a` меньше `<` чем `b`, то вернется `1`, если иное значение, то вернется `0`.

В качестве операторов, у вас есть `==` - сравнение равенства, `!=`- неравенство (отличается от), `<` - меньше, `>` - больше, `<=` - меньше или равно, `>=` - больше или равно, `||` - или (логическое сложение), `&&` - и (логическое умножение), `!` - не (логическое отрицание).

Если мы напишем `!a`, то если в процессе сравнения, `a` будет `0` (false), то вернется 1, если будет иначе `true`, то вернется 0. Поэтому все это называется операторы сравнения.

### 15.2 - Побитовые (бинарные) операторы `>> << | & ^` ###

Также у нас есть то, что мы называем побитовые операторы. Эти операторы буду напрямую обрабатыват двоичные данные переменной. Позже, мы более подробно рассмотрим это, потому что пока нам это не пригодится, но они позволяют обрабатывать каждый бит содержащийся в параменных.

### 15.3 - Составное присваивание (сокращения): ###

```c
a += 10     <=>    a = a + 10
b[50] /= 2  <=>    b[50] = b[50] / 2
a++         <=>    a += 1              <=>    a = a + 1
```

Затем, у нас есть составное присваивание (сокращение), которое позволяет облегчить чтение. Например, мы можем написать `a += 10` и это будет тоже самое, что если мы напишем `a = a + 10`. Мы можем написать `a++`, это будет аналогично написанию `a = a + 1`. Мы можем написать `/=` и это будет тоже самое, что и деление. Все это является просто средством для сокращения написания кода.

### 15.4 - Особенности: ###

```c
'A'   // dec #65 в таблице ASCII
sizeof(type_of_var)
&a    // адрес переменной в памяти ОЗУ
exp1 ? exp2 : exp3
```

Также существуют особенные элементы выражения. Например `'A'`: возвращает ASCII-код символа между между апострофами. на самом деле, ASCII-код для `A` - это 65. ASCII-коды очень важны, так как они позволяют нам отображать символы. Есть ASCII таблица, но мы к этому еще позже вернемся.

У нас есть оператор `sizeof`. Мы пишем `sizeof`, тип переменной, [размер (sizeof) непосредственно самой переменной], и он вернет нам размер, который эта переменная занимает в памяти.

Последнее: если мы добавим `&` перед переменной, то вернется адрес этой переменной в памяти.

У нас также есть тернарная условная операция, которую мы используем довольно редко, ее алгоритм следующий: выражение1, `?`, выражение2, `:`, выражение3, и оно производит анализ по выражению1.
Если выражение не является `null`, то оно вычислит выражение2 и вернет его в качестве значения. Если иначе (else), то оно вычислит выражение3 и вернет его, как значение. Поэтому, это условное выражение.

### 15.5 - Символьные строки ###

```c
"hello forty-two"

/*
автоматически сохраняет последовательность ascii-кодов в массиве символов, который заканчивается на \0; производит вычисления по адресу первого символа.

automatically stores a sequence of ascii codes in a char array ended by 0; evaluates to the address of the first char.
*/
```

Последний пункт, это то, что мы называем символьными строками. Строка - это серия символов между кавычек, происходит выделение памяти для символов между этими самыми кавычками и в конце будет добавлен `\0` (терминирующий ноль) и он вернет адрес первого символа.


# 16. Указатели  #

### 16.1 - Определение: ###

```c
/*
указатель - это переменная, в которой хранится адрес области памяти другой переменной данного ею типа.

a pointer is a variable that stores the memory address of another variable of a given type
*/
```

Когда мы перечисляли типы, то видели один особенный тип - указатели. Указатель - это переменная, как и другие, только вместо хранения данных, она будет хранить адрес другой переменной, ну, или по крайней мере, адрес данных. По сути, это указатель на что-то, и следуя из его названия, он содержит адрес чего-то.

### 16.2 - Объявление: ###

```c
type  *name;

/* Конкретный пример */

int  *p;    // p содержит адрес int переменной
            // p stores the address of an int variable.
```

Как объявить указатель? Сначала мы должны объявить тип того, на что мы указываем, имея в виду тип переменной, адрес которой мы хотим хранить. Итак, мы пишем тип, `*<имя_переменной>`. Например: если мы напишем `int *p`, то `p` будет хранить адрес переменной типа int.

### 16.3 - Применение: ###

```c
int a;
int *p;

p = &a;    // *p = 1;   <=>   a = 1;
*p = 1;


/*
Если (p) содержит адрес (a), то (*p) - это другое имя области памяти (a); <*name> - это объект типа <type>, адрес которого содержится в <name>.

if p stores the address of a, then *p is another name for the memory area of a; <*name> is the object of type <type>, the address of which is stored in <name>.
*/
```

Как мы их используем? Довольно просто. Как только мы объявим указатель типа int, как это сделал я, далее мы пишем `p = &a`: установив в `p` адрес переменной `a`. Потом мы используем `*p`.

Написав `*p = 1;`, мы устанавливаем значение `1` внутрь адреса на который указывает `p`, это тоже самое, что если мы напишем `a = 1`, так как `p` содержит адрес `a`. Так что если `p` содержит адрес `a`, то `*p` - это тоже самое, что и `a`, это таже самая область памяти, тот же адрес и тот же тип.

В принципе, можно сказать, что `*<name>`, то есть `*`, имя переменной типа указателя - это объект типа `<type>`, чей адрес содержится в `<name>`. Это очень важно. Вы должны систематически ссылаться на это определение. Когда у меня есть указатель с именем `<name>`, типа `<type>`, то `*<name>` - это объект типа `<type>`, который хранится в `<name>`.

### 16.4 - Арифметика указателей: ###

```c
int tab[42];
int *p;

p = &(tab[0]);
*(p + x);
```

Итак, у нас еще есть арифметическая система. Давайте возьмем массив `tab[42]`. Итак `p`, объект типа указатель, который хранит адрес первого элемента `0` массива `tab[]`. Если мы напишем `*(p + x)`, то мы получим доступ к значению расположенному в позиции `x` нашего массива, это тоже самое, если бы написали `tab[x]`.


# 17. Управляющие конструкции #

Итак, до этого момента, мы видели объявление переменных, инструкции, и теперь нам осталось разобраться с управляющими конструкциями. Мы увидим 3 таких конструкции, вообще-то мы увидим 4, т.к. 2 из них очень похожи.

### 17.1 Условия `if`: ###

```c
if (expression)
  instructions

if (expression)
  instructions

else
  instructions
```

Первая упр. конструкция - это условный оператор `if`. Все довольно просто: мы пишем `if (выражение)` а затем инструкцию. Эта инструкция может быть блоком, то есть содержать несколько инструкций и объявлений. Как это работает? Все просто: оно вычисляет выражение. Итак, мы собираемся вычислить результат выражения, если выражение возвращает 0, то ничего не происходит, если вернется что-то еще, кроме 0, то выполняется инструкция. Это, по сути, простая проверка и довольна практична в применении.

Есть более продуманный вариант такой конструкции, он выглядит примерно так: `if (выражение) {инструкции} else (другие инструкции). Если 1ое выражение имеет значение 0 (false), то происходит выполнение 2ого выражения. Если 1ое выражение имеет значение 1 (true), то происходит выполнение инструкций 1ого выражения. Все это довольно просто.

### 17.2 Циклы `while`: ###

```c
while (expression)
  instructions
```

Вторая упр. конструкция - это цикл `while` и он довольно прост: `while (выражение), и инструкция`. Сам процесс немного отличается. `while` вычисляет выражение является 0 (false), то цикл останавливается. Если является чем-то другим, нежели 0, то выполняются инструкции.

Выглядит это почти как `if`, за исключением того, что происходит цикл, вместо того, чтобы остановиться. Если выражение является - 0 (false), мы прекращаем выполнение, если иначе - 1 (true), то мы опять выполняем инструкции и возвращаемся к началу.

Следуя из названия цикла `while` (пока), мы выполняем инструкции пока выражение не будет являться - 0 (false). Именно так работают все циклы. Именно так вы будете их использовать во время этого Бассейна. Существуют также другие управляющие структуры, но вы будете использовать только эти.

### 17.3 Оператор возврата `return`: ###

```c
return (expression);
return;
```

Последняя управляющая структура - `return`, которая позволяющая возвращать значения при выходе из функции. Как мы уже видели, функция может принимать входные параметры и возвращать значение на выходе. `return` позволяет нам вернуть это значение, `return( )` вычисляет выражение и останавливает работу функции. Это значит, что если после `return` есть другие инструкции, то они выполняться не будут и возвращаемое значение функции будет результатом этого выражения.

Есть другой тип `return` без возвращаемого значения, предназначенный для определенного типа функции, которого мы еще не видели, но мы увидим его позже. Это функции, которые не могут возвращать значения и имеют другой синтаксис.

По сути на этом урок по Си закончен, ну или по крайней мере он закончен на тех вещах, которые вам будут нужны на бассейне.

#
